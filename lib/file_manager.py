#!/usr/bin/env python3
"""
EmoLanguage File Management Module

Comprehensive file I/O operations for the emoji mapping system, handling all
aspects of data persistence, mapping storage, and file-based operations.
This module serves as the primary data access layer with robust error handling
and efficient file management capabilities.

Key Responsibilities:
    - Word-to-emoji mapping persistence (JSON-based storage)
    - Dictionary file processing and validation
    - Generation logging and audit trails
    - Duplicate detection and cleanup operations
    - File system initialization and management
    - Data integrity validation and recovery

Supported File Formats:
    - JSON: Primary format for mappings and logs
    - Text: Dictionary files and reports
    - Markdown: Generation reports and documentation

Directory Structure:
    - mappings/: Core mapping files and backups
    - logs/: Generation logs, reports, and debug information

Author: EmoLanguage Team
Version: 2.0.0
"""

import json
import logging
import time
from collections import defaultdict
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Set, Any

from .config import MAPPING_FILE_PATH, MAPPINGS_DIR, LOGS_DIR

logger = logging.getLogger(__name__)

# =============================================================================
# DATA STRUCTURES
# =============================================================================

@dataclass
class NewMapping:
    """Represents a new word-to-emoji mapping generated by the system.
    
    This dataclass encapsulates mapping information with metadata about
    the generation process, enabling tracking and analysis of mapping quality.
    
    Attributes:
        word: The normalized word being mapped
        suggested_emojis: The emoji sequence assigned to the word
        category: Classification of how this mapping was generated
        match_score: LLM-provided confidence score (0.0-1.0) for mapping quality
        
    Categories:
        - 'batch': Generated through standard batch processing
        - 'collision_winner': Won a collision resolution
        - 'collision_alternative': Alternative mapping after collision
        - 'multipass_quality_X': Multi-pass generation with quality score
        - 'error': Failed to generate mapping
    
    Example:
        >>> mapping = NewMapping("cat", "🐱", "batch", 0.95)
        >>> mapping.word
        'cat'
        >>> mapping.is_successful()
        True
    """
    word: str
    suggested_emojis: str
    category: str = 'generated'
    match_score: float = 0.0
    generation_timestamp: float = field(default_factory=time.time)
    
    def is_successful(self) -> bool:
        """Check if this mapping was successfully generated."""
        return bool(self.suggested_emojis and self.suggested_emojis.strip())
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert mapping to dictionary for serialization."""
        return {
            'word': self.word,
            'suggested_emojis': self.suggested_emojis,
            'category': self.category,
            'generation_timestamp': self.generation_timestamp,
            'successful': self.is_successful()
        }

class FileManager:
    """Handles all file I/O operations for the emoji mapping system.
    
    This class provides a comprehensive interface for file-based operations
    in the emoji mapping system, including loading and saving mappings,
    detecting collisions, managing logs, and handling dictionary files.
    
    The FileManager maintains consistent file structure, enforces data integrity,
    and provides robust error handling for all file operations.
    
    Attributes:
        mappings_dir: Directory containing mapping files
        logs_dir: Directory containing log files
        mapping_path: Path to the main mapping file
        
    Example:
        >>> manager = FileManager()
        >>> mappings = manager.load_existing_mappings()
        >>> manager.save_mappings(mappings)
    """
    
    def __init__(self) -> None:
        """Initialize file manager and create necessary directory structure.
        
        Creates the required directories for the emoji mapping system and
        validates the configuration. This ensures all file operations can
        proceed without path-related errors.
        
        Raises:
            OSError: If directories cannot be created due to permissions
            ValueError: If configuration paths are invalid
        """
        try:
            self.mappings_dir = Path(MAPPINGS_DIR)
            self.logs_dir = Path(LOGS_DIR)
            self.mapping_path = Path(MAPPING_FILE_PATH)
            
            # Create directories if they don't exist
            self.mappings_dir.mkdir(parents=True, exist_ok=True)
            self.logs_dir.mkdir(parents=True, exist_ok=True)
            
            logger.debug(f"FileManager initialized - mappings: {self.mappings_dir}, logs: {self.logs_dir}")
            
        except Exception as e:
            logger.error(f"Failed to initialize FileManager: {e}")
            raise
    
    def load_dictionary(self, dictionary_path: str) -> List[str]:
        """Load and validate words from a dictionary file.
        
        Reads a text file containing one word per line, filters out empty lines
        and whitespace, and returns a clean list of words for processing.
        
        Args:
            dictionary_path: Path to the dictionary file to load
            
        Returns:
            List of cleaned words from the dictionary file
            
        Raises:
            FileNotFoundError: If the dictionary file does not exist
            IOError: If the file cannot be read
            UnicodeDecodeError: If the file encoding is invalid
            
        Example:
            >>> manager = FileManager()
            >>> words = manager.load_dictionary('dictionaries/english.txt')
            >>> print(f"Loaded {len(words)} words")
        """
        try:
            dictionary_file = Path(dictionary_path)
            if not dictionary_file.exists():
                raise FileNotFoundError(f"Dictionary file '{dictionary_path}' not found")
            
            with open(dictionary_file, 'r', encoding='utf-8') as f:
                words = [line.strip() for line in f if line.strip()]
            
            if not words:
                logger.warning(f"Dictionary file '{dictionary_path}' is empty or contains no valid words")
            else:
                logger.info(f"Loaded {len(words)} words from {dictionary_path}")
            
            return words
            
        except (IOError, OSError, UnicodeDecodeError) as e:
            logger.error(f"Failed to load dictionary '{dictionary_path}': {e}")
            raise
    
    def load_existing_mappings(self) -> Dict[str, str]:
        """Load existing word-to-emoji mappings from the main mapping file.
        
        Reads the primary mapping.json file and returns a dictionary of 
        word-to-emoji mappings. If the file doesn't exist or has issues,
        returns an empty dictionary to allow fresh mapping generation.
        
        Returns:
            Dictionary mapping words to their assigned emoji sequences
            
        Raises:
            No exceptions - errors are logged and empty dict returned
            
        Example:
            >>> manager = FileManager()
            >>> mappings = manager.load_existing_mappings()
            >>> print(f"Found mappings for {len(mappings)} words")
        """
        if not self.mapping_path.exists():
            logger.info("No existing mapping.json found - starting with empty mappings")
            return {}
        
        try:
            with open(self.mapping_path, 'r', encoding='utf-8') as f:
                mappings = json.load(f)
            
            # Validate mapping structure
            if not isinstance(mappings, dict):
                logger.error("Invalid mapping file format - expected dictionary")
                return {}
            
            # Filter out any invalid entries
            clean_mappings = {}
            for word, emoji in mappings.items():
                if isinstance(word, str) and isinstance(emoji, str) and word.strip() and emoji.strip():
                    clean_mappings[word] = emoji
                else:
                    logger.warning(f"Skipping invalid mapping: {word} -> {emoji}")
            
            return clean_mappings
            
        except (json.JSONDecodeError, UnicodeDecodeError) as e:
            logger.error(f"Could not parse mapping.json: {e}")
            return {}
        except (IOError, OSError) as e:
            logger.warning(f"Could not read mapping.json: {e}")
            return {}
    
    def save_mappings(self, mappings: Dict[str, str]) -> Path:
        """Save word-to-emoji mappings to the main mapping file with validation.
        
        Persists the complete word-to-emoji mapping dictionary to JSON format
        with proper formatting and encoding. Validates data integrity before saving.
        
        Args:
            mappings: Dictionary of word-to-emoji mappings to save
            
        Returns:
            Path to the saved mapping file
            
        Raises:
            IOError: If the file cannot be written
            ValueError: If mappings data is invalid
            
        Example:
            >>> manager = FileManager()
            >>> mappings = {"cat": "🐱", "dog": "🐶"}
            >>> path = manager.save_mappings(mappings)
        """
        try:
            # Validate input data
            if not isinstance(mappings, dict):
                raise ValueError(f"Expected dict, got {type(mappings)}")
            
            # Create backup if file exists
            if self.mapping_path.exists():
                backup_path = self.mapping_path.with_suffix('.json.backup')
                self.mapping_path.rename(backup_path)
                logger.debug(f"Created backup at {backup_path}")
            
            # Write new mappings
            with open(self.mapping_path, 'w', encoding='utf-8') as f:
                json.dump(mappings, f, indent=2, ensure_ascii=False, sort_keys=False)
            
            logger.info(f"Successfully saved {len(mappings)} word-to-emoji mappings to {self.mapping_path}")
            return self.mapping_path
            
        except (IOError, OSError, json.JSONEncodeError) as e:
            logger.error(f"Failed to save mappings: {e}")
            raise
    
    def save_generation_log(self, mappings: List[NewMapping], filename: Optional[str] = None) -> Path:
        """Save generated mappings to logs directory for analysis and debugging.
        
        Creates a timestamped log file containing detailed information about
        newly generated mappings, including generation categories and metadata.
        
        Args:
            mappings: List of NewMapping objects to log
            filename: Optional custom filename (auto-generated if None)
            
        Returns:
            Path to the saved log file
            
        Raises:
            IOError: If the log file cannot be written
            
        Example:
            >>> manager = FileManager()
            >>> new_mappings = [NewMapping("cat", "🐱", "batch")]
            >>> log_path = manager.save_generation_log(new_mappings)
        """
        try:
            # Generate filename if not provided
            if filename is None:
                timestamp = int(time.time())
                datetime_str = datetime.fromtimestamp(timestamp).strftime('%Y%m%d_%H%M%S')
                filename = f"generated_mappings_{datetime_str}.json"
            
            output_path = self.logs_dir / filename
            
            # Convert mappings to enriched serializable format
            mappings_data = {
                'generation_metadata': {
                    'timestamp': time.time(),
                    'datetime': datetime.now().isoformat(),
                    'total_mappings': len(mappings),
                    'successful_mappings': sum(1 for m in mappings if m.is_successful())
                },
                'mappings': [mapping.to_dict() for mapping in mappings]
            }
            
            with open(output_path, 'w', encoding='utf-8') as f:
                json.dump(mappings_data, f, indent=2, ensure_ascii=False)
            
            logger.info(f"Saved {len(mappings)} generated mappings to {output_path}")
            return output_path
            
        except (IOError, OSError, json.JSONEncodeError) as e:
            logger.error(f"Failed to save generation log: {e}")
            raise
    
    def save_report(self, report_content: str, filename: str = "generation_report.md") -> Path:
        """Save generation report to logs directory with timestamp.
        
        Writes a human-readable report (typically in Markdown format) containing
        generation statistics, analysis, and other information for review.
        
        Args:
            report_content: The complete report text to save
            filename: Name for the report file (default: generation_report.md)
            
        Returns:
            Path to the saved report file
            
        Raises:
            IOError: If the report file cannot be written
            
        Example:
            >>> manager = FileManager()
            >>> report = "# Generation Report\n\nProcessed 100 words..." 
            >>> report_path = manager.save_report(report)
        """
        try:
            # Add timestamp to filename if not already present
            file_path = Path(filename)
            if not any(char.isdigit() for char in file_path.stem):
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                timestamped_name = f"{file_path.stem}_{timestamp}{file_path.suffix}"
                filename = timestamped_name
                
            report_path = self.logs_dir / filename
            
            # Add header with metadata
            enhanced_content = f"""<!-- Generated: {datetime.now().isoformat()} -->
<!-- File: {report_path.name} -->

{report_content}"""
            
            with open(report_path, 'w', encoding='utf-8') as f:
                f.write(enhanced_content)
            
            logger.info(f"Report saved to {report_path} ({len(report_content)} characters)")
            return report_path
            
        except (IOError, OSError) as e:
            logger.error(f"Failed to save report: {e}")
            raise
    
    def find_and_remove_duplicate_emojis(self) -> Tuple[List[str], List[Tuple[str, str, str]]]:
        """Detect and resolve duplicate emoji assignments in the mapping file.
        
        Analyzes the current mappings to find cases where the same emoji has been
        assigned to multiple words. Removes all conflicting mappings and creates
        collision tuples for LLM-based resolution to ensure emoji uniqueness.
        
        Returns:
            Tuple containing:
            - List of words that need remapping due to duplicate emojis
            - List of collision tuples (word1, word2, conflicted_emoji) for LLM resolution
            
        Example:
            >>> manager = FileManager()
            >>> words_to_remap, collisions = manager.find_and_remove_duplicate_emojis()
            >>> print(f"Found {len(collisions)} emoji conflicts")
        """
        if not self.mapping_path.exists():
            logger.debug("No mapping file exists - no duplicates to check")
            return [], []
        
        try:
            # Load existing mappings
            word_to_emoji = self.load_existing_mappings()
            if not word_to_emoji:
                return [], []
            
            # Group words by their assigned emoji
            emoji_to_words = defaultdict(list)
            for word, emoji in word_to_emoji.items():
                emoji_to_words[emoji].append(word)
            
            # Identify emojis used by multiple words
            duplicates = {emoji: words for emoji, words in emoji_to_words.items() if len(words) > 1}
            
            if not duplicates:
                logger.debug("No duplicate emojis found in current mappings")
                return [], []
            
            # Process duplicates for resolution
            words_to_reprocess = []
            collision_tuples = []
            
            for emoji, conflicting_words in duplicates.items():
                logger.warning(
                    f"Emoji '{emoji}' assigned to {len(conflicting_words)} words: {conflicting_words}"
                )
                
                # Create all possible collision pairs for LLM resolution
                for i in range(len(conflicting_words)):
                    for j in range(i + 1, len(conflicting_words)):
                        collision_tuples.append((conflicting_words[i], conflicting_words[j], emoji))
                
                # Mark all conflicting words for reprocessing
                for word in conflicting_words:
                    word_to_emoji.pop(word, None)
                    words_to_reprocess.append(word)
            
            # Save cleaned mapping without duplicates
            self.save_mappings(word_to_emoji)
            
            logger.info(
                f"Resolved {len(duplicates)} emoji conflicts - "
                f"removed {len(words_to_reprocess)} words for remapping, "
                f"created {len(collision_tuples)} collision pairs for LLM resolution"
            )
            
            return words_to_reprocess, collision_tuples
            
        except Exception as e:
            logger.error(f"Failed to process duplicate emojis: {e}")
            return [], []
    
    def get_existing_emojis(self) -> Set[str]:
        """Retrieve all emoji sequences currently in use.
        
        Returns a set of all unique emoji sequences from the current mappings,
        useful for preventing duplicates during new mapping generation.
        
        Returns:
            Set of emoji strings currently assigned to words
            
        Example:
            >>> manager = FileManager()
            >>> used_emojis = manager.get_existing_emojis()
            >>> print(f"Currently using {len(used_emojis)} unique emojis")
        """
        try:
            mappings = self.load_existing_mappings()
            emoji_set = set(mappings.values())
            logger.debug(f"Retrieved {len(emoji_set)} unique emojis from {len(mappings)} mappings")
            return emoji_set
        except Exception as e:
            logger.error(f"Failed to get existing emojis: {e}")
            return set()
    
    def get_emoji_to_word_mapping(self) -> Dict[str, str]:
        """Create reverse mapping from emoji sequences to their assigned words.
        
        Generates an inverted dictionary mapping emoji sequences back to their
        corresponding words. Useful for conflict detection and emoji lookup.
        
        Returns:
            Dictionary mapping emoji sequences to words
            
        Note:
            If duplicate emojis exist, only one word will be preserved per emoji
            
        Example:
            >>> manager = FileManager()
            >>> emoji_to_word = manager.get_emoji_to_word_mapping()
            >>> word = emoji_to_word.get("🐱", "Unknown")
        """
        try:
            word_to_emoji = self.load_existing_mappings()
            emoji_to_word = {emoji: word for word, emoji in word_to_emoji.items()}
            
            if len(emoji_to_word) != len(word_to_emoji):
                logger.warning(
                    f"Reverse mapping size mismatch: {len(word_to_emoji)} words -> "
                    f"{len(emoji_to_word)} emojis (duplicates detected)"
                )
            
            logger.debug(f"Generated reverse mapping for {len(emoji_to_word)} emoji-to-word pairs")
            return emoji_to_word
            
        except Exception as e:
            logger.error(f"Failed to create emoji-to-word mapping: {e}")
            return {}
    
    def filter_unmapped_words(self, dictionary_words: List[str]) -> List[str]:
        """Filter dictionary words to exclude those already having emoji mappings.
        
        Compares the input word list against existing mappings to identify words
        that still need emoji assignment. This prevents redundant processing.
        
        Args:
            dictionary_words: List of words from dictionary to filter
            
        Returns:
            List of words that don't have existing emoji mappings
            
        Example:
            >>> manager = FileManager()
            >>> all_words = ["cat", "dog", "bird"]
            >>> unmapped = manager.filter_unmapped_words(all_words)
            >>> print(f"Need to process {len(unmapped)} words")
        """
        try:
            existing_mappings = self.load_existing_mappings()
            unmapped_words = [word for word in dictionary_words if word not in existing_mappings]
            
            original_count = len(dictionary_words)
            filtered_count = len(unmapped_words)
            mapped_count = original_count - filtered_count
            
            logger.info(
                f"Dictionary filtering results: {original_count} input words, "
                f"{mapped_count} already mapped, {filtered_count} need processing"
            )
            
            if mapped_count > 0:
                logger.debug(
                    f"Existing mappings cover {mapped_count}/{original_count} "
                    f"({100 * mapped_count / original_count:.1f}%) of dictionary words"
                )
            
            return unmapped_words
            
        except Exception as e:
            logger.error(f"Failed to filter unmapped words: {e}")
            # Return original list if filtering fails
            return dictionary_words

    # =============================================================================
    # UTILITY METHODS
    # =============================================================================
    
    def backup_mappings(self, suffix: Optional[str] = None) -> Optional[Path]:
        """Create a backup of the current mapping file.
        
        Args:
            suffix: Optional suffix for backup filename
            
        Returns:
            Path to backup file if successful, None otherwise
        """
        try:
            if not self.mapping_path.exists():
                logger.info("No mapping file to backup")
                return None
            
            if suffix is None:
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                suffix = f"backup_{timestamp}"
            
            backup_path = self.mapping_path.with_suffix(f'.{suffix}.json')
            self.mapping_path.rename(backup_path)
            
            logger.info(f"Created mapping backup at {backup_path}")
            return backup_path
            
        except Exception as e:
            logger.error(f"Failed to backup mappings: {e}")
            return None
    
    def get_mapping_stats(self) -> Dict[str, Any]:
        """Get comprehensive statistics about current mappings.
        
        Returns:
            Dictionary with mapping statistics and metadata
        """
        try:
            mappings = self.load_existing_mappings()
            
            if not mappings:
                return {'total_mappings': 0, 'unique_emojis': 0, 'has_duplicates': False}
            
            emoji_counts = defaultdict(int)
            for emoji in mappings.values():
                emoji_counts[emoji] += 1
            
            duplicates = {emoji: count for emoji, count in emoji_counts.items() if count > 1}
            
            stats = {
                'total_mappings': len(mappings),
                'unique_emojis': len(emoji_counts),
                'has_duplicates': bool(duplicates),
                'duplicate_count': len(duplicates),
                'file_exists': self.mapping_path.exists(),
                'file_size_bytes': self.mapping_path.stat().st_size if self.mapping_path.exists() else 0
            }
            
            if duplicates:
                stats['duplicates'] = dict(duplicates)
            
            return stats
            
        except Exception as e:
            logger.error(f"Failed to get mapping stats: {e}")
            return {'error': str(e)}
